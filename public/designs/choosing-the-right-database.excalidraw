{
	"type": "excalidraw",
	"version": 2,
	"source": "https://github.com/zsviczian/obsidian-excalidraw-plugin/releases/tag/2.16.1",
	"elements": [
		{
			"id": "cl7YvTyc",
			"type": "text",
			"x": -398.5621061037725,
			"y": -216.7085336538462,
			"width": 2555.166015625,
			"height": 3535,
			"angle": 0,
			"strokeColor": "#1e1e1e",
			"backgroundColor": "transparent",
			"fillStyle": "solid",
			"strokeWidth": 2,
			"strokeStyle": "solid",
			"roughness": 1,
			"opacity": 100,
			"groupIds": [],
			"frameId": null,
			"index": "a0",
			"roundness": null,
			"seed": 67833115,
			"version": 483,
			"versionNonce": 840368501,
			"isDeleted": false,
			"boundElements": null,
			"updated": 1759878630912,
			"link": null,
			"locked": false,
			"text": "Choosing the right database for an application is a crucial decision that impacts scalability, performance, reliability, and development complexity. \nThe decision depends largely on the nature of the data, the scale of operations, expected workload patterns, and specific application use cases. \nHere is a detailed explanation to guide this decision, focusing on data types, scale considerations, scaling approaches, decision patterns, real-life \nexamples, and cloud providers.\n\n\nUnderstanding Data Types\n\n\n    Relational Data: \n        Structured, tabular data with well-defined schemas and relationships (e.g., users, orders, transactions).\n        Relational databases (RDBMS) like PostgreSQL, MySQL, and Microsoft SQL Server excel at enforcing data \n        integrity, supporting ACID transactions, and complex querying with joins and constraints.\n\n    Document Data: \n        Semi-structured or schema-flexible data stored as JSON-like documents. Document databases like MongoDB, \n        Couchbase, and Amazon DocumentDB enable agile development with flexible schemas, easy horizontal scaling, a\n        nd fast reads/writes for nested and varying data.\n\n    Geospatial Data: \n        Location-based data often requiring spatial queries (proximity, path, geofencing). Specialized databases or extensions\n        like PostgreSQL’s PostGIS, Redis Geo, and Google Cloud BigQuery GIS provide geospatial indexing and functions \n        optimized for location analytics.\n\n\nScale Considerations\n\n    Thousands to Millions of Records:\n        - Most traditional RDBMS and NoSQL databases handle this scale comfortably. Vertical scaling (stronger servers) often suffices, and single-node or modest clusters are typical.\n\n    Millions to Billions of Records:\n        - Scaling mostly requires horizontal scaling—sharding data across multiple nodes. Document stores like MongoDB and distributed SQL options like CockroachDB are often preferred.\n          Sophisticated indexing and caching become essential.\n\n    Billions to Trillions of Records:\n        - At this scale, distributed databases specifically designed for big data, event-driven logging, or massive analytical processing come into play. Examples include Apache Cassandra, \n          Google Bigtable, Amazon DynamoDB, and data lakes on cloud data warehouses like Snowflake or Google BigQuery.\n\nWays to Scale Databases\n\n    Vertical Scaling: Increasing compute, memory, and storage of a single node. Simple but limited by hardware.\n\n    Horizontal Scaling: Distributing the database across many nodes (sharding/partitioning). Complex to implement but offers near-linear expansion for very large datasets.\n\n    Caching: Using in-memory stores like Redis or Memcached to speed up reads for frequently accessed data.\n\n    Read Replicas: Duplicating data across read-only nodes for high read throughput and availability.\n\n    Data Archiving & Tiered Storage: Moving older or less accessed data to cheaper, slower storage while keeping hot data in fast storage.\n\nPatterns to Look For When Deciding\n\n    Data Structure & Relationships\n        - If data is highly relational with complex transactions, go for an RDBMS. For flexible schemas or rapidly evolving data, prefer document or key-value stores.\n\n    Consistency vs Availability\n        - Decide trade-offs based on CAP theorem. Financial or critical data often require strong consistency (RDBMS), whereas location or session data might \n          tolerate eventual consistency (NoSQL).\n\n    Query Complexity\n        - Complex joins and ad-hoc queries are better handled by relational databases. Simple key-based retrieval or document queries favor NoSQL.\n\n    Scaling Needs & Latency Requirements\n        - Assess read/write throughput, geo-distribution, and latency SLAs. For global scale with low latency, consider distributed NoSQL or NewSQL solutions.\n\n    Operational Complexity & Ecosystem Support\n        - Factor in ease of management, backup, replication, security, monitoring, and compatibility with existing tools.\n\nReal-Life Examples\n\n    Relational Databases\n        PostgreSQL is widely used in financial services, e-commerce platforms, and ride-sharing apps.\n        Microsoft SQL Server in enterprise applications.\n        Cloud providers offer these as managed services: Amazon RDS, Google Cloud SQL, Azure SQL Database.\n\n    Document Databases\n        MongoDB powers content management, user profiles, and IoT data.\n        Couchbase used in gaming and real-time apps.\n        Managed offerings include MongoDB Atlas, Amazon DocumentDB, and Azure Cosmos DB.\n\n    Geospatial Databases\n        PostGIS on PostgreSQL is used in logistics and mapping services.\n        Redis Geo is popular for live location tracking in transportation apps.\n        Google BigQuery GIS and AWS Location Service provide managed geospatial analytics.\n\n    Big Data and Wide-Column Stores\n        Cassandra for large-scale time series and telemetry data (e.g., Netflix, Apple).\n        DynamoDB for serverless, massively scalable apps (e.g., Amazon's own services).\n        Cloud providers offer these as fully managed services.\n\nConclusion\n\nChoosing a database requires matching the data type and query patterns to the strengths and weaknesses of the database technology. \nConsider the scale of data and the complexity of operations, and select solutions that allow you to start simple but scale horizontally as\n demand grows. Leveraging managed services from cloud providers like AWS, Google Cloud, and Microsoft Azure can greatly reduce operational\n overhead while providing scalability and resilience.\n\nMaking this choice early helps ensure the application performs reliably and adapts to increased usage without costly rewrites or migrations later.\nThis explanation should provide a detailed, clear framework for database selection tailored to different data types, use cases, and scales.\n\n",
			"rawText": "Choosing the right database for an application is a crucial decision that impacts scalability, performance, reliability, and development complexity. \nThe decision depends largely on the nature of the data, the scale of operations, expected workload patterns, and specific application use cases. \nHere is a detailed explanation to guide this decision, focusing on data types, scale considerations, scaling approaches, decision patterns, real-life \nexamples, and cloud providers.\n\n\nUnderstanding Data Types\n\n\n    Relational Data: \n        Structured, tabular data with well-defined schemas and relationships (e.g., users, orders, transactions).\n        Relational databases (RDBMS) like PostgreSQL, MySQL, and Microsoft SQL Server excel at enforcing data \n        integrity, supporting ACID transactions, and complex querying with joins and constraints.\n\n    Document Data: \n        Semi-structured or schema-flexible data stored as JSON-like documents. Document databases like MongoDB, \n        Couchbase, and Amazon DocumentDB enable agile development with flexible schemas, easy horizontal scaling, a\n        nd fast reads/writes for nested and varying data.\n\n    Geospatial Data: \n        Location-based data often requiring spatial queries (proximity, path, geofencing). Specialized databases or extensions\n        like PostgreSQL’s PostGIS, Redis Geo, and Google Cloud BigQuery GIS provide geospatial indexing and functions \n        optimized for location analytics.\n\n\nScale Considerations\n\n    Thousands to Millions of Records:\n        - Most traditional RDBMS and NoSQL databases handle this scale comfortably. Vertical scaling (stronger servers) often suffices, and single-node or modest clusters are typical.\n\n    Millions to Billions of Records:\n        - Scaling mostly requires horizontal scaling—sharding data across multiple nodes. Document stores like MongoDB and distributed SQL options like CockroachDB are often preferred.\n          Sophisticated indexing and caching become essential.\n\n    Billions to Trillions of Records:\n        - At this scale, distributed databases specifically designed for big data, event-driven logging, or massive analytical processing come into play. Examples include Apache Cassandra, \n          Google Bigtable, Amazon DynamoDB, and data lakes on cloud data warehouses like Snowflake or Google BigQuery.\n\nWays to Scale Databases\n\n    Vertical Scaling: Increasing compute, memory, and storage of a single node. Simple but limited by hardware.\n\n    Horizontal Scaling: Distributing the database across many nodes (sharding/partitioning). Complex to implement but offers near-linear expansion for very large datasets.\n\n    Caching: Using in-memory stores like Redis or Memcached to speed up reads for frequently accessed data.\n\n    Read Replicas: Duplicating data across read-only nodes for high read throughput and availability.\n\n    Data Archiving & Tiered Storage: Moving older or less accessed data to cheaper, slower storage while keeping hot data in fast storage.\n\nPatterns to Look For When Deciding\n\n    Data Structure & Relationships\n        - If data is highly relational with complex transactions, go for an RDBMS. For flexible schemas or rapidly evolving data, prefer document or key-value stores.\n\n    Consistency vs Availability\n        - Decide trade-offs based on CAP theorem. Financial or critical data often require strong consistency (RDBMS), whereas location or session data might \n          tolerate eventual consistency (NoSQL).\n\n    Query Complexity\n        - Complex joins and ad-hoc queries are better handled by relational databases. Simple key-based retrieval or document queries favor NoSQL.\n\n    Scaling Needs & Latency Requirements\n        - Assess read/write throughput, geo-distribution, and latency SLAs. For global scale with low latency, consider distributed NoSQL or NewSQL solutions.\n\n    Operational Complexity & Ecosystem Support\n        - Factor in ease of management, backup, replication, security, monitoring, and compatibility with existing tools.\n\nReal-Life Examples\n\n    Relational Databases\n        PostgreSQL is widely used in financial services, e-commerce platforms, and ride-sharing apps.\n        Microsoft SQL Server in enterprise applications.\n        Cloud providers offer these as managed services: Amazon RDS, Google Cloud SQL, Azure SQL Database.\n\n    Document Databases\n        MongoDB powers content management, user profiles, and IoT data.\n        Couchbase used in gaming and real-time apps.\n        Managed offerings include MongoDB Atlas, Amazon DocumentDB, and Azure Cosmos DB.\n\n    Geospatial Databases\n        PostGIS on PostgreSQL is used in logistics and mapping services.\n        Redis Geo is popular for live location tracking in transportation apps.\n        Google BigQuery GIS and AWS Location Service provide managed geospatial analytics.\n\n    Big Data and Wide-Column Stores\n        Cassandra for large-scale time series and telemetry data (e.g., Netflix, Apple).\n        DynamoDB for serverless, massively scalable apps (e.g., Amazon's own services).\n        Cloud providers offer these as fully managed services.\n\nConclusion\n\nChoosing a database requires matching the data type and query patterns to the strengths and weaknesses of the database technology. \nConsider the scale of data and the complexity of operations, and select solutions that allow you to start simple but scale horizontally as\n demand grows. Leveraging managed services from cloud providers like AWS, Google Cloud, and Microsoft Azure can greatly reduce operational\n overhead while providing scalability and resilience.\n\nMaking this choice early helps ensure the application performs reliably and adapts to increased usage without costly rewrites or migrations later.\nThis explanation should provide a detailed, clear framework for database selection tailored to different data types, use cases, and scales.\n\n",
			"fontSize": 28,
			"fontFamily": 5,
			"textAlign": "left",
			"verticalAlign": "top",
			"containerId": null,
			"originalText": "Choosing the right database for an application is a crucial decision that impacts scalability, performance, reliability, and development complexity. \nThe decision depends largely on the nature of the data, the scale of operations, expected workload patterns, and specific application use cases. \nHere is a detailed explanation to guide this decision, focusing on data types, scale considerations, scaling approaches, decision patterns, real-life \nexamples, and cloud providers.\n\n\nUnderstanding Data Types\n\n\n    Relational Data: \n        Structured, tabular data with well-defined schemas and relationships (e.g., users, orders, transactions).\n        Relational databases (RDBMS) like PostgreSQL, MySQL, and Microsoft SQL Server excel at enforcing data \n        integrity, supporting ACID transactions, and complex querying with joins and constraints.\n\n    Document Data: \n        Semi-structured or schema-flexible data stored as JSON-like documents. Document databases like MongoDB, \n        Couchbase, and Amazon DocumentDB enable agile development with flexible schemas, easy horizontal scaling, a\n        nd fast reads/writes for nested and varying data.\n\n    Geospatial Data: \n        Location-based data often requiring spatial queries (proximity, path, geofencing). Specialized databases or extensions\n        like PostgreSQL’s PostGIS, Redis Geo, and Google Cloud BigQuery GIS provide geospatial indexing and functions \n        optimized for location analytics.\n\n\nScale Considerations\n\n    Thousands to Millions of Records:\n        - Most traditional RDBMS and NoSQL databases handle this scale comfortably. Vertical scaling (stronger servers) often suffices, and single-node or modest clusters are typical.\n\n    Millions to Billions of Records:\n        - Scaling mostly requires horizontal scaling—sharding data across multiple nodes. Document stores like MongoDB and distributed SQL options like CockroachDB are often preferred.\n          Sophisticated indexing and caching become essential.\n\n    Billions to Trillions of Records:\n        - At this scale, distributed databases specifically designed for big data, event-driven logging, or massive analytical processing come into play. Examples include Apache Cassandra, \n          Google Bigtable, Amazon DynamoDB, and data lakes on cloud data warehouses like Snowflake or Google BigQuery.\n\nWays to Scale Databases\n\n    Vertical Scaling: Increasing compute, memory, and storage of a single node. Simple but limited by hardware.\n\n    Horizontal Scaling: Distributing the database across many nodes (sharding/partitioning). Complex to implement but offers near-linear expansion for very large datasets.\n\n    Caching: Using in-memory stores like Redis or Memcached to speed up reads for frequently accessed data.\n\n    Read Replicas: Duplicating data across read-only nodes for high read throughput and availability.\n\n    Data Archiving & Tiered Storage: Moving older or less accessed data to cheaper, slower storage while keeping hot data in fast storage.\n\nPatterns to Look For When Deciding\n\n    Data Structure & Relationships\n        - If data is highly relational with complex transactions, go for an RDBMS. For flexible schemas or rapidly evolving data, prefer document or key-value stores.\n\n    Consistency vs Availability\n        - Decide trade-offs based on CAP theorem. Financial or critical data often require strong consistency (RDBMS), whereas location or session data might \n          tolerate eventual consistency (NoSQL).\n\n    Query Complexity\n        - Complex joins and ad-hoc queries are better handled by relational databases. Simple key-based retrieval or document queries favor NoSQL.\n\n    Scaling Needs & Latency Requirements\n        - Assess read/write throughput, geo-distribution, and latency SLAs. For global scale with low latency, consider distributed NoSQL or NewSQL solutions.\n\n    Operational Complexity & Ecosystem Support\n        - Factor in ease of management, backup, replication, security, monitoring, and compatibility with existing tools.\n\nReal-Life Examples\n\n    Relational Databases\n        PostgreSQL is widely used in financial services, e-commerce platforms, and ride-sharing apps.\n        Microsoft SQL Server in enterprise applications.\n        Cloud providers offer these as managed services: Amazon RDS, Google Cloud SQL, Azure SQL Database.\n\n    Document Databases\n        MongoDB powers content management, user profiles, and IoT data.\n        Couchbase used in gaming and real-time apps.\n        Managed offerings include MongoDB Atlas, Amazon DocumentDB, and Azure Cosmos DB.\n\n    Geospatial Databases\n        PostGIS on PostgreSQL is used in logistics and mapping services.\n        Redis Geo is popular for live location tracking in transportation apps.\n        Google BigQuery GIS and AWS Location Service provide managed geospatial analytics.\n\n    Big Data and Wide-Column Stores\n        Cassandra for large-scale time series and telemetry data (e.g., Netflix, Apple).\n        DynamoDB for serverless, massively scalable apps (e.g., Amazon's own services).\n        Cloud providers offer these as fully managed services.\n\nConclusion\n\nChoosing a database requires matching the data type and query patterns to the strengths and weaknesses of the database technology. \nConsider the scale of data and the complexity of operations, and select solutions that allow you to start simple but scale horizontally as\n demand grows. Leveraging managed services from cloud providers like AWS, Google Cloud, and Microsoft Azure can greatly reduce operational\n overhead while providing scalability and resilience.\n\nMaking this choice early helps ensure the application performs reliably and adapts to increased usage without costly rewrites or migrations later.\nThis explanation should provide a detailed, clear framework for database selection tailored to different data types, use cases, and scales.\n\n",
			"autoResize": true,
			"lineHeight": 1.25
		},
		{
			"id": "KsbwlBgm",
			"type": "text",
			"x": -400.25,
			"y": -312.15234375,
			"width": 1109.3397216796875,
			"height": 45,
			"angle": 0,
			"strokeColor": "#1e1e1e",
			"backgroundColor": "transparent",
			"fillStyle": "solid",
			"strokeWidth": 2,
			"strokeStyle": "solid",
			"roughness": 1,
			"opacity": 100,
			"groupIds": [],
			"frameId": null,
			"index": "a1",
			"roundness": null,
			"seed": 673757429,
			"version": 75,
			"versionNonce": 1835555797,
			"isDeleted": false,
			"boundElements": null,
			"updated": 1759878642096,
			"locked": false,
			"text": "How do you decide which database to choose for your system?",
			"rawText": "How do you decide which database to choose for your system?",
			"fontSize": 36,
			"fontFamily": 5,
			"textAlign": "left",
			"verticalAlign": "top",
			"containerId": null,
			"originalText": "How do you decide which database to choose for your system?",
			"autoResize": true,
			"lineHeight": 1.25
		},
		{
			"id": "gUXrn7_kw6bc5CTFCuhfm",
			"type": "line",
			"x": -408.6486304012342,
			"y": -253.46768904321019,
			"width": 1115.137924382716,
			"height": 2.3274191568462754,
			"angle": 0,
			"strokeColor": "#1e1e1e",
			"backgroundColor": "transparent",
			"fillStyle": "solid",
			"strokeWidth": 2,
			"strokeStyle": "solid",
			"roughness": 1,
			"opacity": 100,
			"groupIds": [],
			"frameId": null,
			"index": "a3",
			"roundness": {
				"type": 2
			},
			"seed": 1020777141,
			"version": 120,
			"versionNonce": 530918651,
			"isDeleted": false,
			"boundElements": null,
			"updated": 1759878441313,
			"link": null,
			"locked": false,
			"points": [
				[
					0,
					0
				],
				[
					1115.137924382716,
					-2.3274191568462754
				]
			],
			"lastCommittedPoint": null,
			"startBinding": null,
			"endBinding": null,
			"startArrowhead": null,
			"endArrowhead": null,
			"polygon": false
		}
	],
	"appState": {
		"theme": "light",
		"viewBackgroundColor": "#ffffff",
		"currentItemStrokeColor": "#1e1e1e",
		"currentItemBackgroundColor": "transparent",
		"currentItemFillStyle": "solid",
		"currentItemStrokeWidth": 2,
		"currentItemStrokeStyle": "solid",
		"currentItemRoughness": 1,
		"currentItemOpacity": 100,
		"currentItemFontFamily": 5,
		"currentItemFontSize": 28,
		"currentItemTextAlign": "left",
		"currentItemStartArrowhead": null,
		"currentItemEndArrowhead": "arrow",
		"currentItemArrowType": "round",
		"currentItemFrameRole": null,
		"scrollX": 1446.2654671717212,
		"scrollY": 862.3391392558076,
		"zoom": {
			"value": 0.26
		},
		"currentItemRoundness": "round",
		"gridSize": 20,
		"gridStep": 5,
		"gridModeEnabled": false,
		"gridColor": {
			"Bold": "rgba(217, 217, 217, 0.5)",
			"Regular": "rgba(230, 230, 230, 0.5)"
		},
		"currentStrokeOptions": null,
		"frameRendering": {
			"enabled": true,
			"clip": true,
			"name": true,
			"outline": true,
			"markerName": true,
			"markerEnabled": true
		},
		"objectsSnapModeEnabled": false,
		"activeTool": {
			"type": "selection",
			"customType": null,
			"locked": false,
			"fromSelection": false,
			"lastActiveTool": null
		}
	},
	"prevTextMode": "parsed",
	"files": {}
}